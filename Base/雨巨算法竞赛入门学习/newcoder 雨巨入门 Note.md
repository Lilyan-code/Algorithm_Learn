# newcoder 雨巨入门 Note

## 1. 枚举和贪心

### 时间复杂度

- 时间复杂度是衡量程序的运行速度的量度， 它在衡量的时候忽略了硬件的差异。
- 它是一个定性描述程序运行时间和数据规模n的关系的函数，这个函数即程序执行基本操作（加减寻址赋值简单的数学函数等）的次数， 记做T(n)
- 大O表示法：考察n趋近于正无穷时的情况
- 当前仅当存在常数c>0和N>=1,对一切n>N均有|g(n)| <= c|f(n)|成立，称函数g(n)以f(n)为渐进上界或者称g(n)受限于f(n), 记做g(n) = O(f(n))。
- 常见的时间复杂度
    - O(1) 和输入数据规模无关
    - O(logn) 一般我们默认底数是2，不是2也没关系，用换底公式之后就是常数了
    - O(√𝑛)
    - O(n) 线性时间复杂度
    - O(n^2)•O(n^3)......
    - O(C^n) C是一个常数，指数级
    - O(n!) 阶乘级

### 空间复杂度

- 计算机内各种变量的存储
- ![](https://i.loli.net/2021/04/25/OAj9MW7XbBpUomx.png)
- ![](https://i.loli.net/2021/04/25/hiEYlU4AD9zj5QM.png)
- 计算变量所占的空间
    - 8位二进制= 1个字节
    - 1024字节= lKB
    - 1024kB = 1MB
    - 1024MB = 1GB

### 1.1 枚举

#### 前缀和

- 给你一个数列{an}（1≤n≤100000），有q（1≤q≤100000）次询问，每次询问数列的第li个元素到第ri个元素的和。
    - 暴力解法： 对区间的查询需要将整个区间扫一遍， O(nq)
    - 优化： 将对区间的查询变为区间端点的查询（前缀和问题）， 
        - 我们可以使用一个数组sum, sum[i]代表存储前i个数的和， 那么sum[i] = sum[i - 1] + a[i], 当我们查询第li个元素到第ri个元素的和的时候，用sum[ri] - sum[li- 1]即可
        - 单次查询的时间为O(1), 总的时间为O(n + q)

#### 差分

- 给你一个数列{an}（1≤n≤100000），有q（1≤q≤100000）次修改，每次把数列中的第li到第ri的每个元素都加上一个值ki，求所有的修改之后每个数的值。
    - 暴力解法： 对区间的查询需要将整个区间扫一遍， O(nq)
    - 优化： <font color='red'>考虑在区间加的过程中有什么值是在区间端点处发生了变化而区间内是没有变化的</font>: <font color='pink'>是每一个数与其前一个数的差值</font>
        - 当我们对第li个数到第ri个数加上ki时，第li个数与第li-1个数的差值增加了ki，第ri+1个数与第ri个数的差值减少了ki，而区间内部的相邻两个数的差值是不变的
        - 我们使用数组sub[i]维护第i个数和其前一个数的差值，（可以默认第一个数前面有一个0），然后当需要将[li,ri]区间的每一个数+ki时，只修改sub[[li]]和sub[ri+1]即可。
        - 在所有修改操作做完以后，我们再对sub[i]求一次前缀和，就可以得到数列的每个元素的值。

> 差分和前缀和是一对对称的操作（即对差分数组求前缀和就是原数组，对前缀和求差分也会得到原数组）

#### 例子： 校门外的树

- 某校大门外长度为L的马路上有一排树，每两棵相邻的树之间的间隔都是1米。我们可以把马路看成一个数轴，马路的一端在数轴0的位置，另一端在L的位置；数轴上的每个整数点，即0,1,2,...,L都种有一棵树。由于马路上有一些区域要用来建地铁。这些区域用它们在数轴上的起始点和终止点表示。已知任一区域的起始点和终止点的坐标都是整数，区域之间可能有重合的部分。现在要把这些区域中的树（包括区域端点处的两棵树）移走。你的任务是计算将这些树都移走后，马路上还有多少棵树。
- 1≤L≤10000和1≤M≤100：枚举暴力可解决
- 1≤L≤100000和1≤M≤100000： 我们把每个数轴上有树的点标为1， 在区间的树就进行减掉1操作， 维护区间端点， 最后在再取前缀和
- 1≤L≤10^9和1≤M≤100000： 离散化后再维护区间端点

#### 例子： 双指针（[POJ 3061 Sequence](http://poj.org/problem?id=3061)）

- 给定长度为n的整数数列以及整数S，求出总和不小于S的连续子串的长度的最小值，如果解不存在，输出0.<font color='red'>数据范围: 10 < N < 10^6, S < 10^7</font>

    - 暴力枚举左端点和右端点，再求和， 时间复杂度为O(n^3)
    - 使用双指针算法（尺取法）：
        - 以$a_{s}$开始总和最初大于S时的连续子序列为$a_s+...+a_{t-1}$,有$a_{s+1}+...+a_{t-2} < a_s+...+a_{t-2}$,所以从$a_{s+1}$开始总和最初超过S的连续子序列如果是$a_{s+1} + ...+ a_{t^{'} - 1}$，则必然有$t <= t^{'}$。
        - 以s = t = sum = 0初始化。
        - 只要依然有sum < S，就不断将sum增加$a_t$, 并将t增加1.
        - 如果上述中无法满足sum >= S则终止。否则，更新res = min(res, t - s)
        - 将sum减去$a_s$, s增加1然后返回第二点

- ```cpp
    #include <cstdio>
    #include <cstring>
    #include <cstdlib>
    #include <iostream>
    using namespace std;
    
    const int N = 1e6 + 5;
    
    int a[N];
    int sum[N];
    
    int main() {
        int t, n, s;
        scanf("%d", &t);
        while (t --) {
            memset(a, 0 , sizeof(a));
            memset(sum, 0, sizeof(sum));
            scanf("%d%d", &n, &s);
            for (int i = 0; i < n; i ++)
                scanf("%d", &a[i]);
    
            int left = 0, right = 0;
            int tmp = 0;
            // bool flag = false;
            if (sum[n - 1] < s) {
                printf("0\n");
            } else {
                int res = N + 1;
                while (1) {
                    while (tmp < s && right < n)
                        tmp += a[right++];
                    if (tmp < s) 
                        break;
                    res = min(res, right - left);
                    tmp = tmp - a[left++];
                }
                printf("%d\n", res);
            }
                
        }
        return 0;
    }
        
    ```

#### 位运算

